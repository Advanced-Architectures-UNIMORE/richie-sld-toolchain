<%
######################
## Logic data types ##
######################
%>

<%def name="logic(width)">\
  <%
    if width == 1:
      typ = 'logic        '
    else:
      typ = "logic [%3d:0]" % (width - 1)
  %>
  ${typ}\
</%def>\
<%  
    try:
        TARGET = target.upper()
        n_tcdm_ports = n_sink + n_source
    except:
        pass
%>
<%
############################
## Kernel wrapper signals ##
############################
%>

<%def name="AND_local_done_in_ASSIGN(n_sink)">\
\
% if (n_sink > 1):
% for i in range (n_sink-1): 
(local_done_in_${i}) & \
% endfor 
(local_done_in_${i+1});\
% endif 
\
% if (n_sink == 1):
local_done_in_0;\
% endif
\
</%def>\

<%def name="AND_local_done_out_ASSIGN(n_source)">\
\
% if (n_source > 1):
% for i in range (n_source-1): 
(local_done_out_${i}) & \
% endfor 
(local_done_out_${i+1});\
% endif 
\
% if (n_source == 1):
local_done_out_0;\
% endif
\
</%def>\

<%def name="AND_local_done_out_IF(n_source)">\
\
% if (n_source > 1):
% for i in range (n_source-1): 
(local_done_out_${i}) & \
% endfor 
(local_done_out_${i+1})\
% endif 
\
% if (n_source == 1):
local_done_out_0\
% endif
\
</%def>\
<%
#############
## Generic ##
#############
%>

<%def name="port(name, data_type, width, output, active_low=False)">\
  <%
    if output:
      direction = 'output'
      suffix = 'o'
    else:
      direction = 'input '
      suffix = 'i'
    if width == 1:
      typ = '        '
    else:
      typ = "[%3d:0] " % (width - 1)
    if active_low:
      suffix = 'n' + suffix
    name = name + '_' + suffix
  %>
  % if (width > 0):
  ${direction} ${data_type} ${typ} ${name}\
  % endif
</%def>\

<%
###############
## AXI ports ##
###############
%>

<%def name="axi_w_ports(prefix, master, dw)">\
  ${port(prefix + '_data', dw, master)},\
  ${port(prefix + '_strb', dw/8, master)},\
  ${port(prefix + '_last', 1, master)},\
  ${port(prefix + '_valid', 1, master)},\
  ${port(prefix + '_ready', 1, not master)}\
</%def>\

<%def name="axi_b_ports(prefix, master, iw)">\
  ${port(prefix + '_id', iw, not master)},\
  ${port(prefix + '_resp', 2, not master)},\
  ${port(prefix + '_valid', 1, not master)},\
  ${port(prefix + '_ready', 1, master)}\
</%def>\

<%def name="axi_r_ports(prefix, master, dw, iw)">\
  ${port(prefix + '_id', iw, not master)},\
  ${port(prefix + '_data', dw, not master)},\
  ${port(prefix + '_resp', 2, not master)},\
  ${port(prefix + '_last', 1, not master)},\
  ${port(prefix + '_valid', 1, not master)},\
  ${port(prefix + '_ready', 1, master)}\
</%def>\

<%def name="axi_ports(prefix, master, aw, dw, iw, uw)">\
  ${axi_ax_ports(prefix + '_aw', master, aw, iw, uw)},\
  ${axi_w_ports(prefix + '_w', master, dw)},\
  ${axi_b_ports(prefix + '_b', master, iw)},\
  ${axi_ax_ports(prefix + '_ar', master, aw, iw, uw)},\
  ${axi_r_ports(prefix + '_r', master, dw, iw)}\
</%def>\

<%def name="axi_lite_ax_ports(prefix, master, aw)">\
  ${port(prefix + '_addr', aw, master)},\
  ${port(prefix + '_prot', 3, master)},\
  ${port(prefix + '_valid', 1, master)},\
  ${port(prefix + '_ready', 1, not master)}\
</%def>\

<%def name="axi_lite_w_ports(prefix, master, dw)">\
  ${port(prefix + '_data', dw, master)},\
  ${port(prefix + '_strb', dw/8, master)},\
  ${port(prefix + '_valid', 1, master)},\
  ${port(prefix + '_ready', 1, not master)}\
</%def>\

<%def name="axi_lite_b_ports(prefix, master)">\
  ${port(prefix + '_resp', 2, not master)},\
  ${port(prefix + '_valid', 1, not master)},\
  ${port(prefix + '_ready', 1, master)}\
</%def>\

<%def name="axi_lite_r_ports(prefix, master, dw)">\
  ${port(prefix + '_data', dw, not master)},\
  ${port(prefix + '_resp', 2, not master)},\
  ${port(prefix + '_valid', 1, not master)},\
  ${port(prefix + '_ready', 1, master)}\
</%def>\

<%def name="axi_lite_ports(prefix, master, aw, dw)">\
  ${axi_lite_ax_ports(prefix + '_aw', master, aw)},\
  ${axi_lite_w_ports(prefix + '_w', master, dw)},\
  ${axi_lite_b_ports(prefix + '_b', master)},\
  ${axi_lite_ax_ports(prefix + '_ar', master, aw)},\
  ${axi_lite_r_ports(prefix + '_r', master, dw)}\
</%def>\

<%def name="axi_stream_inst_in(prefix, index, n_ports)">\
.${prefix}_TDATA  ( i_${stream_in[index]}.data  ), \
.${prefix}_TVALID ( i_${stream_in[index]}.valid ), \
.${prefix}_TREADY ( i_${stream_in[index]}.ready ), \
</%def>\

<%def name="axi_stream_inst_out(prefix, index, n_ports)">\
.${prefix}_TDATA  ( o_${stream_out[index]}.data  ), \
.${prefix}_TVALID ( o_${stream_out[index]}.valid ), \
.${prefix}_TREADY ( o_${stream_out[index]}.ready ), \
</%def>\

<%
#########################
## Streamer interfaces ##
#########################
%>

<%def name="stream_intf_stream_decl_1(name, data_width, clk_name)">\
hwpe_stream_intf_stream #( .DATA_WIDTH(${data_width}) ) ${name} ( .clk (${clk_name}) );
</%def>\

// <%def name="stream_intf_stream_decl_2(name, data_width, stream_dir)">\
// hwpe_stream_intf_stream.${stream_dir} ${name},
// </%def>\

<%def name="stream_instance(name, io_dir, stream_dir)">\
.${name}_${io_dir}              ( ${name}.${stream_dir}       ), \
</%def>\

<%
#####################
## TCDM interfaces ##
#####################
%>

<%def name="stream_intf_tcdm_decl(prefix , name, data_width, clk_name)">\
hwpe_stream_intf_tcdm ${prefix}_${name} [${data_width}:0] ( .clk (${clk_name}) );
</%def>\

<%
#############################
## Job-dependent registers ##
#############################
%>

<%def name="static_reg_decl(type, prefix, name, dim, index)">\
% if len(prefix)>0:
% if len(type)>0:
${type} [(${dim}-1):0] ${prefix}_${name}; \
% else:
${type} [(${dim}-1):0] ${prefix}_${name}_${index}; \
% endif
% else:
% if len(type)>0:
${type} [(${dim}-1):0] ${name}; \
% else:
${type} [(${dim}-1):0] ${name}_${index}; \
% endif
% endif
</%def>\

<%def name="static_reg_assign(name)">\
<% NAME = name.upper() %>
assign static_reg_${name} = reg_file.hwpe_params[${target}_REG_${NAME}]; \
</%def>\

<%def name="static_reg_to_engine_intf(name, isport)">\
  % if isport:
.${name}        ( ctrl_i.${name}      ),
  % endif
</%def>\

<%def name="static_reg_to_kernel_module(name, isport, dim)">\
  % if isport:
input logic [${dim-1}:0] ${name},
  % endif
</%def>\

<%def name="static_reg_to_kernel_hls_intf(name, isport, dim, reg_num, reg_offset)">\
% if (reg_offset < reg_num):
  % if isport:
.${name}   ( ${name} ),
  % endif
% else:
  % if isport:
.${name}   ( ${name} )
  % endif
% endif
</%def>\

<%def name="fsm_t_size(trans_size_reg, streampath, current_stream)">\
  % if current_stream == streampath:
${trans_size_reg};
  % else:
len;
  % endif
</%def>\

<%
#######################################
## Library of components - Streaming ##
#######################################
%>

<%
##################################
## Streaming - Kernel interface ##
##################################
%>

<%def name="streaming_kernel_intf()">\

  // Sink ports
  % for i in range (n_sink):
    % if (is_parallel_in[i]):
      % for k in range (in_parallelism_factor[i]):
  hwpe_stream_intf_stream.sink i_${stream_in[i]}_${k},
      % endfor
    % else:
  hwpe_stream_intf_stream.sink i_${stream_in[i]},
    % endif
  % endfor 

  // Source ports
  % for j in range (n_source):
    % if (is_parallel_out[j]):
      % for k in range (out_parallelism_factor[j]):
  hwpe_stream_intf_stream.source o_${stream_out[j]}_${k},
      % endfor
    % else:
  hwpe_stream_intf_stream.source o_${stream_out[j]},
    % endif
  % endfor 

</%def>\
<%
############################################################
## Kernel interface -> Xilinx ap_ctrl_hs (refer to UG902) ##
############################################################
%>

<%def name="intf_hls()">\

  ciao

  % if is_intf is True:

  /* ${target} hardware kernel. */

  ${target} i_${target} (
    // Global signals.
    .ap_clk             ( clk_i            ), 
    .ap_rst_n           ( rst_ni           ), 

    // Input data (to-hwpe)
    % for i in range (n_sink):
    .${stream_in[i]}_TDATA  ( i_${stream_in[i]}.data  ), \
    .${stream_in[i]}_TVALID ( i_${stream_in[i]}.valid ), \
    .${stream_in[i]}_TREADY ( i_${stream_in[i]}.ready ), \
    % endfor 

    // Output data (from-hwpe)
    % for j in range (n_source):
    .${stream_out[j]}_TDATA  ( ${stream_out[j]}_o.data  ), \
    .${stream_out[j]}_TVALID ( ${stream_out[j]}_o.valid ), \
    .${stream_out[j]}_TREADY ( ${stream_out[j]}_o.ready ), \
    % endfor 

    // Algorithm parameters.
    % for i in range (custom_reg_num):
      % if custom_reg_isport[i]:
    .${custom_reg_name[i]}   ( ${custom_reg_name[i]} ),
      % endif
    % endfor 

    // Control signals.
    .ap_start           ( start            ),
    .ap_done            ( done             ), 
    .ap_idle            ( idle             ), 
    .ap_ready           ( ready            )
  );

  % endif

</%def>\

<%
################################
## Engine controls (from FSM) ##
################################
%>

<%def name="ctrl_to_engine()">\

  % if is_intf is True:

  /* ${target} control signals. */

  % endif

</%def>\

<%
###########################
## Engine flags (to FSM) ##
###########################
%>

<%def name="flags_from_engine()">\

  % if is_intf is True:

  /* ${target} flag signals. */

  logic done, idle, ready;

  assign flags_o.done = done;
  assign flags_o.idle = idle;
  assign flags_o.cnt = cnt_out;

  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_ready
    if(~rst_ni)
      flags_o.ready = 1'b0;
    else if(~(ready | idle))
      flags_o.ready = 1'b0;
    else
      flags_o.ready = 1'b1;
  end

  // IN/OUT synchronization
  logic unsigned [$clog2(${target}_CNT_LEN):0] cnt_in; 
  logic unsigned [$clog2(${target}_CNT_LEN):0] cnt_out;

  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_in
    if((~rst_ni) | clear)
      cnt_in = 32'b0;
    else if((a_i.valid)&(a_i.ready))
      cnt_in = cnt_in + 1;
    else
      cnt_in = cnt_in;
  end

  always_ff @(posedge clk_i or negedge rst_ni or posedge done)
  begin: engine_cnt_out
    if((~rst_ni) | clear)
      cnt_out = 32'b0;
    else if((done)&(cnt_in>cnt_out))
      cnt_out = cnt_out + 1;
    else
      cnt_out = cnt_out;
  end

  % endif

</%def>\

<%
#########################
## Streaming interface ##
#########################
%>

<%def name="intf_streaming()">\

  % if is_intf is True:

  /* ${target} streaming interface control. */

  // At the moment output strobe is always '1
  // All bytes of output streams are written
  // to TCDM
  always_comb
  begin
    % for j in range (n_source):
    o_${stream_out[j]}.strb = '1;
    % endfor
  end

  % endif

</%def>\


<%
#######################################
## Kernel interface -> MDC dataflow  ##
#######################################
%>

<%def name="intf_hls()">\

  % if is_intf is True:

  /* ${target} hardware kernel. */

  ${target} i_${target} (
    // Global signals.
    .ap_clk             ( clk_i            ), 
    .ap_rst_n           ( rst_ni           ), 

    // Input data (to-hwpe)
    % for i in range (n_sink):
    .${stream_in[i]}_TDATA  ( i_${stream_in[i]}.data  ), \
    .${stream_in[i]}_TVALID ( i_${stream_in[i]}.valid ), \
    .${stream_in[i]}_TREADY ( i_${stream_in[i]}.ready ), \
    % endfor 

    // Output data (from-hwpe)
    % for j in range (n_source):
    .${stream_out[j]}_TDATA  ( ${stream_out[j]}_o.data  ), \
    .${stream_out[j]}_TVALID ( ${stream_out[j]}_o.valid ), \
    .${stream_out[j]}_TREADY ( ${stream_out[j]}_o.ready ), \
    % endfor 

    % if custom_reg_num > 0:
    // Algorithm parameters
    % for i in range (custom_reg_num):
    ${static_reg_to_kernel_hls_intf(custom_reg_name[i], custom_reg_isport[i], custom_reg_dim[i], custom_reg_num, i+1)}
    % endfor 
    % endif

  );

  % endif

</%def>\

<%
########################
## Signal declaration ##
########################
%>

<%def name="sign_declaration()">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} control signals. */

  logic local_start;

  /* ${target} flag signals. */

  // FIXME: This won't scale up with large interfaces (unrolling, and so on).
  // SOL: Use array or custom typedef.

  // Input signal flags
  % for i in range (n_sink):
  logic local_ready_in_${i};
  logic local_done_in_${i}; //FIXEME: to be removed
  % endfor

  // Output signal flags
  % for j in range (n_source):
  logic local_done_out_${j};
  % endfor

  logic set_idle;
  logic local_idle;

  /* Counters. */

  % for i in range (n_sink):
  logic unsigned [($clog2(${target}_CNT_LEN)+1):0] local_cnt_${stream_in[i]};
  % endfor

  % for j in range (n_source):
  logic unsigned [($clog2(${target}_CNT_LEN)+1):0] local_cnt_${stream_out[j]};
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

<%
################################
## Engine controls (from FSM) ##
################################
%>

<%def name="ctrl_to_engine()">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} control signals. */

  // Start is not always high. For each ready (~(engine_ready | engine_idle)) that is
  // delivered to the FSM, a new Start signal is set high 
  // and received by the kernel wrapper.

  assign local_start = start;

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

<%
###########################
## Engine flags (to FSM) ##
###########################
%>

<%def name="flags_from_engine()">\

  % if is_intf is True:
  
  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Done. */
  // A done is generated for each output. These are counted and 
  // delivered to the FSM that decides when to update the address
  // on the basis of the state of the line processing (see HWPE-docs).

  // FIXME: This temporarily works synch-outputs.
  // EX: What if Out_0 is provided at each input and Out_1 once per 10 inputs?
  assign done = ${AND_local_done_out_ASSIGN(n_source)} 

  % for j in range (n_source):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_done_${j}
    if(~rst_ni)
      local_done_out_${j} = 1'b0;
    else if((o_${stream_out[j]}.valid)&(o_${stream_out[j]}.ready))
      local_done_out_${j} = 1'b1;
    else
      local_done_out_${j} = 1'b0;
  end
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Ready. */
  /* This is used in the hwpe-engine to set flags_o.ready. 
     The latter triggers the START of accelerator. (see FSM_COMPUTE). */
  /* Driven using input counters. */

  assign ready = ${AND_local_done_in_ASSIGN(n_sink)}

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Idle. */
  /* This is used in the hwpe-engine to set flags_o.ready. 
     The latter triggers the START of accelerator. (see FSM_COMPUTE). */
  /* For more infos refer to UG902. */

  assign idle = local_idle;

  /* The Idle signal indicates when the design is idle and not operating. */
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_idle
		if(~rst_ni) begin
      local_idle = 1'b0;
    end 
    else if(local_start) begin
      /* Idle goes Low immediately after Start to indicate the design is no longer idle. */
      /* If the Start signal is High when Ready is High, the design continues to operate,
          and the Idle signal remains Low. */
			local_idle = 1'b0;
    end 
    else if((!local_start) & (ready)) begin 
      if( ${AND_local_done_out_IF(n_source)} ) begin
        /* If the Start signal is Low when Ready is High, the design stops operation, and
            the ap_idle signal goes High one cycle after ap_done.*/
        local_idle = 1'b1;
      end
    end 
    else begin
			local_idle = local_idle;
    end
  end

  % endif

</%def>\

<%
#########################
## Streaming interface ##
#########################
%>

<%def name="intf_streaming()">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} streaming interface control. */

  // At the moment output strobe is always '1
  // All bytes of output streams are written
  // to TCDM
  always_comb
  begin
    % for j in range (n_source):
    ${stream_out[j]}_o.strb = '1;
    % endfor
  end

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

  <%
  ####################
  ## Input counters ##
  ####################
  %>

<%def name="input_counters()">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} input counters. Ready. */

  % for i in range (n_sink):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_${stream_in[i]}
    if((~rst_ni) | clear) begin
      local_cnt_${stream_in[i]} = 32'b0;
    end
    else if(local_start) begin
      local_cnt_${stream_in[i]} = 32'b0;
    end
    else if ((i_${stream_in[i]}.valid) & (i_${stream_in[i]}.ready)) begin
      local_cnt_${stream_in[i]} = local_cnt_${stream_in[i]} + 1;
    end
    else begin
      local_cnt_${stream_in[i]} = local_cnt_${stream_in[i]};
    end
  end

  // FIXME: Now local_done_in goes High every time an input enters the acc.
  // This should be generalized. Even though the wrapper looper is designed to 
  // on counting the ouputs, the number of inputs needed to generate an ouput
  // are usually > 1.
  // SOL: Add to ctrl_i also the information about max_input.
  assign local_done_in_${i} = (local_cnt_${stream_in[i]}==1) ? 1 : 0;
    
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

  <%
  #####################
  ## Output counters ##
  #####################
  %>

<%def name="output_counters()">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} output counters. */
  // Suggested design:
  //      ap_done = done_out0 & ... & done_outM;
  //      done_outM = cnt_out,i == ctrl_i.max_out,i; (for i=1,..,N)
  // However, loop ctrl is already implemented in micro-code looper that sits
  // in the hwpe-ctrl. Thus, the done information provided by this stage should 
  // concern a single output element, not a tile (block,..).
  // FIXME: At this point, cnt_out is not essential here and could be removed.

  % for j in range (n_source):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_${stream_out[j]}
    if((~rst_ni) | clear)
      local_cnt_${stream_out[j]} = 32'b0;
    else if(!local_idle) begin
      if((${stream_out[j]}_o.valid)&(${stream_out[j]}_o.ready))
        local_cnt_${stream_out[j]} = local_cnt_${stream_out[j]} + 1;
      else
        local_cnt_${stream_out[j]} = local_cnt_${stream_out[j]};
    end
  end
  assign cnt_${stream_out[j]} = local_cnt_${stream_out[j]};
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\


/*
 * HWPE: Francesco Conti <fconti@iis.ee.ethz.ch>
 *
 * Copyright (C) 2018 ETH Zurich, University of Bologna
 * Copyright and related rights are licensed under the Solderpad Hardware
 * License, Version 0.51 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
 * or agreed to in writing, software, hardware and materials distributed under
 * this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * HWPE author: Francesco Conti <fconti@iis.ee.ethz.ch>
 * HWPE specialization tool: Gianluca Bellocchi <gianluca.bellocchi@unimore.it>
 *
 * Module: ${target}_kernel_adapter.sv
 * 
 */

import ${target}_package::*;

module ${target}_kernel_adapter (\

  // Global signals
  input  logic          clk_i,
  input  logic          rst_ni,
  input  logic          test_mode_i,

  // Data streams
  ${streaming_kernel_intf()}

  % if custom_reg_num > 0:
  // Kernel parameters
    % for i in range (custom_reg_num):
  input logic [${custom_reg_dim[i]-1}:0] ${custom_reg_name[i]},
    % endfor 
  % endif

  // Control signals
  input  logic          start,

  // Flag signals
  output logic          done,
  output logic          idle,
  output logic          ready
);

  <%
  ############################################################
  ## Kernel interface -> Xilinx ap_ctrl_hs (refer to UG902) ##
  ############################################################
  %>

  ${intf_hls          ()}
  ${ctrl_to_engine    ()}
  ${flags_from_engine ()}
  ${intf_streaming    ()}

  <%
  #######################################
  ## Kernel interface -> MDC dataflow  ##
  #######################################
  %>

  ${sign_declaration  ()}
  ${intf_hls          ()}
  ${ctrl_to_engine    ()}
  ${flags_from_engine ()}
  ${input_counters    ()}
  ${output_counters   ()}
  ${intf_streaming    ()}

endmodule\

