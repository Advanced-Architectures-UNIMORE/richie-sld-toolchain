<%
#####################################
## Library of components - Control ##
#####################################
%>

<%
######################################
## Control - Number of IO registers ##
######################################
%>

<%
  # IO registers - What?
  # To this category grasp a number of classes of HWPE registers
  # that are required to to support the operations of the accelerated 
  # kernel. To this end, these registered are accessible by the cluster
  # cores that can thus execute R/W operations. These tipically include
  # standard and custom registers, as well those pertaining to programmability
  # of the streamer (e.g. address generator and TCDM master port addresses).
%>

<%def name="ctrl_n_io_regs()">\

<%
  # The methodology to calculate the number of IO registers is similar to the
  # offset calculation in the "hwpe_package" module. Basically, the registers
  # information that is specified by the user in the input specification file
  # is analyzed to gather the total amount of required entities. A "n_io_regs"
  # counter is incremented up to the final value that will be instantiated in 
  # the rendered SystemVerilog module.
%>

<%
  # Initialize n_io_regs counter 
  n_io_regs = 0
%>

<%
  # Counting standard registers

  # these do not vary with the number of source streams: 
  #     "nb_iter", "linestride", "tilestride"
  n_io_regs += std_reg_num - 1 

  # "cnt_limit" on the other side is parametrized on the number of source streams 
  # it is used in the FSM to know how many engine "done" events terminate kernel execution
  for j in range (n_source):
    n_io_regs += 1 
  endfor
  
%>

<%
  # Counting custom registers
  n_io_regs += custom_reg_num
%>

<%
  # Counting address generator registers - Input streams

  # Each data port is associated to an address generator that
  # maps streams to TCDM addresses. To define an address are
  # required num_regs_per_port parameters to be defined.

  num_regs_per_port = 8

  # In case interface partitioning is employed, additional
  # parameters are added up to define the partitioned ports 
  # offset and the data step. The latter is otherwise hardwired.

  num_regs_per_port_parallel = 10

  for i in range (n_sink):
    if (addr_gen_in_isprogr[i]):
      if (is_parallel_in[i]):
        n_io_regs += num_regs_per_port_parallel
      else:
        n_io_regs += num_regs_per_port
      endif
    endif
  endfor
%>

<%
  # Counting address generator registers - Output streams

  # Each data port is associated to an address generator that
  # maps streams to TCDM addresses. To define an address are
  # required num_regs_per_port parameters to be defined.

  num_regs_per_port = 8

  # In case interface partitioning is employed, additional
  # parameters are added up to define the partitioned ports 
  # offset and the data step. The latter is otherwise hardwired.

  num_regs_per_port_parallel = 10

  for j in range (n_source):
    if (addr_gen_out_isprogr[j]):
      if (is_parallel_out[j]):
        n_io_regs += num_regs_per_port_parallel
      else:
        n_io_regs += num_regs_per_port
      endif
    endif
  endfor
%>

<%
  # Counting TCDM
  n_io_regs += n_sink + n_source
%>

<%
  # Instantiate at RTL-level
%>

    .N_IO_REGS ( ${n_io_regs} ),

</%def>\<%
#######################################
## Library of components - Streaming ##
#######################################
%>

<%
###########################################
## Streaming - Top interface declaration ##
###########################################
%>

<%def name="streaming_top_intf()">\

  // Streamer interfaces
  % for i in range (n_sink):
    % if (is_parallel_in[i]):
      % for k in range (in_parallelism_factor[i]):
  hwpe_stream_intf_stream #( .DATA_WIDTH(32) ) ${stream_in[i]}_${k} ( .clk (clk_i) );
      % endfor
    % else:
  hwpe_stream_intf_stream #( .DATA_WIDTH(32) ) ${stream_in[i]} ( .clk (clk_i) );
    % endif
  % endfor 

  % for j in range (n_source):
    % if (is_parallel_out[j]):
      % for k in range (out_parallelism_factor[j]):
  hwpe_stream_intf_stream #( .DATA_WIDTH(32) ) ${stream_out[j]}_${k} ( .clk (clk_i) );
      % endfor
    % else:
  hwpe_stream_intf_stream #( .DATA_WIDTH(32) ) ${stream_out[j]} ( .clk (clk_i) );
    % endif
  % endfor

</%def>\

<%
##################################
## Streaming - Engine interface ##
##################################
%>

<%def name="streaming_engine_intf()">\

    % for i in range (n_sink):
      % if (is_parallel_in[i]):
        % for k in range (in_parallelism_factor[i]):
    .${stream_in[i]}_${k}_i              ( ${stream_in[i]}_${k}.sink       ),
        % endfor
      % else:
    .${stream_in[i]}_i              ( ${stream_in[i]}.sink       ),
      % endif
    % endfor 

    % for j in range (n_source):
      % if (is_parallel_out[j]):
        % for k in range (out_parallelism_factor[j]):
    .${stream_out[j]}_${k}_o              ( ${stream_out[j]}_${k}.source       ),
        % endfor
      % else:
    .${stream_out[j]}_o              ( ${stream_out[j]}.source       ),
      % endif
    % endfor 

</%def>\

<%
####################################
## Streaming - Streamer interface ##
####################################
%>

<%def name="streaming_streamer_intf()">\

    % for i in range (n_sink):
      % if (is_parallel_in[i]):
        % for k in range (in_parallelism_factor[i]):
    .${stream_in[i]}_${k}              ( ${stream_in[i]}_${k}.source       ),
        % endfor
      % else:
    .${stream_in[i]}              ( ${stream_in[i]}.source       ),
      % endif
    % endfor 

    % for j in range (n_source):
      % if (is_parallel_out[j]):
        % for k in range (out_parallelism_factor[j]):
    .${stream_out[j]}_${k}              ( ${stream_out[j]}_${k}.sink       ),
        % endfor
      % else:
    .${stream_out[j]}              ( ${stream_out[j]}.sink       ),
      % endif
    % endfor 

</%def>\/*
 * HWPE: Francesco Conti <fconti@iis.ee.ethz.ch>
 *
 * Copyright (C) 2018 ETH Zurich, University of Bologna
 * Copyright and related rights are licensed under the Solderpad Hardware
 * License, Version 0.51 (the "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
 * or agreed to in writing, software, hardware and materials distributed under
 * this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * HWPE author: Francesco Conti <fconti@iis.ee.ethz.ch>
 * HWPE specialization tool: Gianluca Bellocchi <gianluca.bellocchi@unimore.it>
 *
 * Module: ${target}_top.sv
 * 
 */


