<%
#################################################
## Library of components - FSM synchronization ##
#################################################
%>

<%
# To track the handshakes of the parallel output streams, and-ing them and
# count the latter signals is a way of reducing the overall number of FF 
# required to track the engine activity. Moreover, the trackers are 1-bit
# so they scale well with parallelized interfaces.

# Thus, the trackers are connected to the parallel streams, then the counters 
# are used for the different categories of stream_out.
%>

<%
###############################################
## FSM synchronization - Signals declaration ##
###############################################
%>

<%def name="cnt_out_decl()">\

  // Declaration of counters 

  % for j in range (n_source):
  logic unsigned [($clog2(${TARGET}_CNT_LEN)+1):0] cnt_${stream_out[j]};
  % endfor

</%def>\

<%def name="out_track_decl()">\

  // Declaration of trackers

  % for j in range (n_source):
    % if (is_parallel_out[j]):
      % for k in range (out_parallelism_factor[j]):
  logic unsigned track_${stream_out[j]}_${k};
      % endfor
    % endif
  % endfor

</%def>\

<%
####################################################
## FSM synchronization - AND-ing tracking signals ##
####################################################
%>

<%def name="AND_parallel_track_out()">\
\
  % for j in range (n_source-1):
      % if (is_parallel_out[j]):
          % for k in range (out_parallelism_factor[j]):
track_${stream_out[j]}_${k} & \
          % endfor
      % endif
  % endfor
\
  % if (is_parallel_out[n_source-1]):
      % for k in range (out_parallelism_factor[n_source-1]-1):
track_${stream_out[n_source-1]}_${k} & \
      % endfor
track_${stream_out[n_source-1]}_${out_parallelism_factor[n_source-1]-1}; \
  % endif
\
</%def>\

<%
##########################################
## FSM synchronization - Implementation ##
##########################################
%>

<%def name="cnt_out_ff_impl()">\

  // Counter implementation (FF)
  % for j in range (n_source):
    % if (is_parallel_out[j]):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: ${stream_out[j]}_cnt
    if((~rst_ni) | clear)
      cnt_${stream_out[j]} = 32'b0;
    else if( track_${stream_out[j]}_AND )
      cnt_${stream_out[j]} = cnt_${stream_out[j]} + 1;
    else
      cnt_${stream_out[j]} = cnt_${stream_out[j]};
  end
    % else:
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: ${stream_out[j]}_cnt
    if((~rst_ni) | clear)
      cnt_${stream_out[j]} = 32'b0;
    else if( (${stream_out[j]}.valid) & (${stream_out[j]}.ready) & (done) )
      cnt_${stream_out[j]} = cnt_${stream_out[j]} + 1;
    else
      cnt_${stream_out[j]} = cnt_${stream_out[j]};
  end
    % endif
  % endfor 

</%def>\

<%def name="out_track_impl()">\

  // AND-ed trackers implementation (FF)
  % for j in range (n_source):
    % if (is_parallel_out[j]):
      % for k in range (out_parallelism_factor[j]):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: ${stream_out[j]}_${k}_tracker
    if((~rst_ni) | clear)
      track_${stream_out[j]}_${k} = 1'b0;
    else if( (${stream_out[j]}_${k}.valid) & (${stream_out[j]}_${k}.ready) & (done) )
      track_${stream_out[j]}_${k} = 1'b1;
    else
      track_${stream_out[j]}_${k} = 1'b0;
  end
      % endfor
  assign track_${stream_out[j]}_AND = ${AND_parallel_track_out()}
    % else:
    % endif
  % endfor 

</%def>\

<%
#######################################################
## FSM synchronization - Connection to flag (to FSM) ##
#######################################################
%>

<%def name="cnt_out_assign_to_fsm()">\

  // Assign to fsm flags
  % for j in range (n_source):
  assign flags_o.cnt_${stream_out[j]} = cnt_${stream_out[j]};
  % endfor

</%def>\