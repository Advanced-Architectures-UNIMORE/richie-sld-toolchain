<%
####################################
## Kernel interface -> DATA-FLOW  ##
####################################
%>

<%def name="intf_hls(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ${target} hardware kernel. */

  ${target} i_${target} (
    // Global signals.
    .ap_clk             ( clk_i            ), 
    .ap_rst_n           ( rst_ni           ), 

    // Input data (to-hwpe).
    % for i in range (n_sink):
    ${axi_stream_inst_in(stream_in[i], i, (n_sink + n_source))}
    % endfor 

    // Output data (from-hwpe).
    % for j in range (n_source):
    ${axi_stream_inst_out(stream_out[j], j+i+1, (n_sink + n_source))}
    % endfor 

    // Algorithm parameters.
    % for i in range (custom_reg_num-1):
    ${static_reg_to_engine_intf(custom_reg_name[i], custom_reg_isport[i])}
    % endfor 
    .${custom_reg_name[i+1]}        (  ctrl_i.${custom_reg_name[i+1]}      )

    
  );

  % endif

</%def>\

<%
################################
## Engine controls (from FSM) ##
################################
%>

<%def name="ctrl_to_engine(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} control signals. */

  // Insert start

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

  <%
  ####################
  ## Input counters ##
  ####################
  %>

<%def name="input_counters(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} input counters. */

  % for i in range (n_sink):
  logic unsigned [($clog2(${target}_CNT_LEN)+1):0] cnt_${chr(i+97)}; 
  % endfor

  % for i in range (n_sink):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_${chr(i+97)}
    if((~rst_ni) | clear)
      cnt_${chr(i+97)} = 32'b0;
    else if((${chr(i+97)}_i.valid)&(${chr(i+97)}_i.ready))
      cnt_${chr(i+97)} = cnt_${chr(i+97)} + 1;
    else
      cnt_${chr(i+97)} = cnt_${chr(i+97)};
  end
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

  <%
  #####################
  ## Output counters ##
  #####################
  %>

<%def name="output_counters(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} output counters. */

  % for j in range (n_source):
  logic unsigned [($clog2(${target}_CNT_LEN)+1):0] cnt_${chr(j+n_sink+97)};
  % endfor 

  % for j in range (n_source):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_${chr(j+n_sink+97)}
    if((~rst_ni) | clear)
      cnt_${chr(j+n_sink+97)} = 32'b0;
    else if((${chr(j+n_sink+97)}_o.valid)&(${chr(j+n_sink+97)}_o.ready))
      cnt_${chr(j+n_sink+97)} = cnt_${chr(j+n_sink+97)} + 1;
    else
      cnt_${chr(j+n_sink+97)} = cnt_${chr(j+n_sink+97)};
  end

  // FIXME: This temporarily works with a single output.
  // SOL:   Parametrize flags_o.
  assign flags_o.cnt = cnt_${chr(j+n_sink+97)};
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

<%
###########################
## Engine flags (to FSM) ##
###########################
%>

<%def name="flags_from_engine(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} flag signals. */

  % for j in range (n_source):
  logic local_done_${j};
  % endfor

  logic local_idle, local_ready;
  
  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Done. */

  // FIXME: Generate only when MAX_OUT is reached
  % for j in range (n_source):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_done_${j}
    if(~rst_ni)
      local_done_${j} = 1'b0;
    else if((${chr(j+n_sink+97)}_o.valid)&(${chr(j+n_sink+97)}_o.ready))
      local_done_${j} = 1'b1;
    else
      local_done_${j} = 1'b0;
  end

  // FIXME: This temporarily works with a single output.
  // SOL:   Parametrize flags_o.
  assign done = local_done_${j};
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Ready. */

  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_ready
    if(~rst_ni)
      local_ready = 1'b0;
    else if(
      % for j in range (n_source-1):
      ( (${chr(j+n_sink+97)}_o.valid) & (${chr(j+n_sink+97)}_o.ready) ) & \
      % endfor
      ( (${chr(j+n_sink+97)}_o.valid) & (${chr(j+n_sink+97)}_o.ready) )
    )
      local_ready = 1'b1;
    else
      local_ready = 1'b0;
  end

  assign ready = local_ready;

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Idle. */

  always_comb begin
    if(start)
      local_idle = 1'b0;
    else if(
      % for j in range (n_source-1):
      ( (${chr(j+n_sink+97)}_o.valid) & (${chr(j+n_sink+97)}_o.ready) ) & \
      % endfor
      ( (${chr(j+n_sink+97)}_o.valid) & (${chr(j+n_sink+97)}_o.ready) )
    )
      local_idle = 1'b1;
  end
  
  assign idle = local_idle;

  % endif

</%def>\

<%
#########################
## Streaming interface ##
#########################
%>

<%def name="intf_streaming(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} streaming interface control. */

  // At the moment output strobe is always '1
  // All bytes of output streams are written
  // to TCDM
  always_comb
  begin
    % for i in range (n_sink, n_sink + n_source):
    ${chr(i+97)}_o.strb = '1;
    % endfor
  end

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

