<%
####################################
## Kernel interface -> DATA-FLOW  ##
####################################
%>

<%def name="intf_hls(is_intf, target, stream_in, stream_out, n_sink, n_source)">\

  % if is_intf is True:

  /* ${target} hardware kernel. */

  ${target} i_${target} (
    // Global signals.
    .ap_clk             ( clk_i            ), 
    .ap_rst_n           ( rst_ni           ), 

    // Input data (to-hwpe)
    % for i in range (n_sink):
    .${stream_in[i]}_TDATA  ( ${stream_in[i]}_i.data  ), \
    .${stream_in[i]}_TVALID ( ${stream_in[i]}_i.valid ), \
    .${stream_in[i]}_TREADY ( ${stream_in[i]}_i.ready ), \
    % endfor 

    // Output data (from-hwpe)
    % for j in range (n_source):
    .${stream_out[j]}_TDATA  ( ${stream_out[j]}_o.data  ), \
    .${stream_out[j]}_TVALID ( ${stream_out[j]}_o.valid ), \
    .${stream_out[j]}_TREADY ( ${stream_out[j]}_o.ready ), \
    % endfor 

    % if custom_reg_num > 0:
    // Algorithm parameters
    % for i in range (custom_reg_num):
    ${static_reg_to_kernel_hls_intf(custom_reg_name[i], custom_reg_isport[i], custom_reg_dim[i], custom_reg_num, i+1)}
    % endfor 
    % endif

  );

  % endif

</%def>\

<%
########################
## Signal declaration ##
########################
%>

<%def name="sign_declaration(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} control signals. */

  logic local_start;

  /* ${target} flag signals. */

  // FIXME: This won't scale up with large interfaces (unrolling, and so on).
  // SOL: Use array or custom typedef.

  // Input signal flags
  % for i in range (n_sink):
  logic local_ready_in_${i};
  logic local_done_in_${i}; //FIXEME: to be removed
  % endfor

  // Output signal flags
  % for j in range (n_source):
  logic local_done_out_${j};
  % endfor

  logic set_idle;
  logic local_idle;

  /* Counters. */

  % for i in range (n_sink):
  logic unsigned [($clog2(${target}_CNT_LEN)+1):0] local_cnt_${chr(i+97)};
  % endfor

  % for j in range (n_source):
  logic unsigned [($clog2(${target}_CNT_LEN)+1):0] local_cnt_${chr(j+n_sink+97)};
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

<%
################################
## Engine controls (from FSM) ##
################################
%>

<%def name="ctrl_to_engine(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} control signals. */

  // Start is not always high. For each ready (~(engine_ready | engine_idle)) that is
  // delivered to the FSM, a new Start signal is set high 
  // and received by the kernel wrapper.

  assign local_start = start;

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

<%
###########################
## Engine flags (to FSM) ##
###########################
%>

<%def name="flags_from_engine(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:
  
  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Done. */
  // A done is generated for each output. These are counted and 
  // delivered to the FSM that decides when to update the address
  // on the basis of the state of the line processing (see HWPE-docs).

  // FIXME: This temporarily works synch-outputs.
  // EX: What if Out_0 is provided at each input and Out_1 once per 10 inputs?
  assign done = ${AND_local_done_out_ASSIGN(n_source)} 

  % for j in range (n_source):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_done_${j}
    if(~rst_ni)
      local_done_out_${j} = 1'b0;
    else if((${chr(j+n_sink+97)}_o.valid)&(${chr(j+n_sink+97)}_o.ready))
      local_done_out_${j} = 1'b1;
    else
      local_done_out_${j} = 1'b0;
  end
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Ready. */
  /* This is used in the hwpe-engine to set flags_o.ready. 
     The latter triggers the START of accelerator. (see FSM_COMPUTE). */
  /* Driven using input counters. */

  assign ready = ${AND_local_done_in_ASSIGN(n_sink)}

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* Idle. */
  /* This is used in the hwpe-engine to set flags_o.ready. 
     The latter triggers the START of accelerator. (see FSM_COMPUTE). */
  /* Driven using Start and Done. */

  assign idle = local_idle;

  /* The Idle signal indicates when the design is idle and not operating. */
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_idle
		if(~rst_ni) begin
      local_idle = 1'b0;
    end 
    else if(local_start) begin
      /* Idle goes Low immediately after Start to indicate the design is no longer idle. */
      /* If the Start signal is High when Ready is High, the design continues to operate,
          and the Idle signal remains Low. */
			local_idle = 1'b0;
    end 
    else if((!local_start) & (ready)) begin 
      if( ${AND_local_done_out_IF(n_source)} ) begin
        /* If the Start signal is Low when Ready is High, the design stops operation, and
            the ap_idle signal goes High one cycle after ap_done.*/
        local_idle = 1'b1;
      end
    end 
    else begin
			local_idle = local_idle;
    end
  end

  % endif

</%def>\

<%
#########################
## Streaming interface ##
#########################
%>

<%def name="intf_streaming(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} streaming interface control. */

  // At the moment output strobe is always '1
  // All bytes of output streams are written
  // to TCDM
  always_comb
  begin
    % for j in range (n_source):
    ${stream_out[j]}_o.strb = '1;
    % endfor
  end

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

  <%
  ####################
  ## Input counters ##
  ####################
  %>

<%def name="input_counters(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} input counters. Ready. */

  % for i in range (n_sink):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_${chr(i+97)}
    if((~rst_ni) | clear) begin
      local_cnt_${chr(i+97)} = 32'b0;
    end
    else if(local_start) begin
      local_cnt_${chr(i+97)} = 32'b0;
    end
    else if ((${stream_in[i]}_i.valid) & (${stream_in[i]}_i.ready)) begin
      local_cnt_${chr(i+97)} = local_cnt_${chr(i+97)} + 1;
    end
    else begin
      local_cnt_${chr(i+97)} = local_cnt_${chr(i+97)};
    end
  end

  // FIXME: Now local_done_in goes High everytime an input enters the acc.
  // This should be generalized. Even though the wrapper looper is designed to 
  // on counting the ouputs, the number of inputs needed to generate an ouput
  // are usually > 1.
  // SOL: Add to ctrl_i also the information about max_input.
  assign local_done_in_${i} = (local_cnt_${chr(i+97)}==1) ? 1 : 0;
    
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

  <%
  #####################
  ## Output counters ##
  #####################
  %>

<%def name="output_counters(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  /* ${target} output counters. */
  // Suggested design:
  //      ap_done = done_out0 & ... & done_outM;
  //      done_outM = cnt_out,i == ctrl_i.max_out,i; (for i=1,..,N)
  // However, loop ctrl is already implemented in micro-code looper that sits
  // in the hwpe-ctrl. Thus, the done information provided by this stage should 
  // concern a single data element, not a tile (block,..).
  // FIXME: At this point, cnt_out 

  % for j in range (n_source):
  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_${chr(j+n_sink+97)}
    if((~rst_ni) | clear)
      local_cnt_${chr(j+n_sink+97)} = 32'b0;
    else if(!local_idle) begin
      if((${stream_out[j]}_o.valid)&(${stream_out[j]}_o.ready))
        local_cnt_${chr(j+n_sink+97)} = local_cnt_${chr(j+n_sink+97)} + 1;
      else
        local_cnt_${chr(j+n_sink+97)} = local_cnt_${chr(j+n_sink+97)};
    end
  end
  assign cnt_${chr(j+n_sink+97)} = local_cnt_${chr(j+n_sink+97)};
  % endfor

  /* ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ */

  % endif

</%def>\

