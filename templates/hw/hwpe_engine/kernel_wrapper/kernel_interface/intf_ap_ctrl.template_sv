<%
##############################################
## Kernel interface -> AP_CTRL (Vivado HLS) ##
##############################################
%>

<%def name="intf_hls(is_intf, target, stream_in, stream_out, n_sink, n_source)">\

  % if is_intf is True:

  /* ${target} hardware kernel. */

  ${target} i_${target} (
    // Global signals.
    .ap_clk             ( clk_i            ), 
    .ap_rst_n           ( rst_ni           ), 

    // Input data (to-hwpe)
    % for i in range (n_sink):
    .${stream_in[i]}_TDATA  ( ${stream_in[i]}_i.data  ), \
    .${stream_in[i]}_TVALID ( ${stream_in[i]}_i.valid ), \
    .${stream_in[i]}_TREADY ( ${stream_in[i]}_i.ready ), \
    % endfor 

    // Output data (from-hwpe)
    % for j in range (n_source):
    .${stream_out[j]}_TDATA  ( ${stream_out[j]}_o.data  ), \
    .${stream_out[j]}_TVALID ( ${stream_out[j]}_o.valid ), \
    .${stream_out[j]}_TREADY ( ${stream_out[j]}_o.ready ), \
    % endfor 

    // Algorithm parameters.
    % for i in range (custom_reg_num):
      % if custom_reg_isport[i]:
    .${custom_reg_name[i]}   ( ${custom_reg_name[i]} ),
      % endif
    % endfor 

    // Control signals.
    .ap_start           ( start            ),
    .ap_done            ( done             ), 
    .ap_idle            ( idle             ), 
    .ap_ready           ( ready            )
  );

  % endif

</%def>\

<%
################################
## Engine controls (from FSM) ##
################################
%>

<%def name="ctrl_to_engine(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ${target} control signals. */

  % endif

</%def>\

<%
###########################
## Engine flags (to FSM) ##
###########################
%>

<%def name="flags_from_engine(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ${target} flag signals. */

  logic done, idle, ready;

  assign flags_o.done = done;
  assign flags_o.idle = idle;
  assign flags_o.cnt = cnt_out;

  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_ready
    if(~rst_ni)
      flags_o.ready = 1'b0;
    else if(~(ready | idle))
      flags_o.ready = 1'b0;
    else
      flags_o.ready = 1'b1;
  end

  // IN/OUT synchronization
  logic unsigned [$clog2(${target}_CNT_LEN):0] cnt_in; 
  logic unsigned [$clog2(${target}_CNT_LEN):0] cnt_out;

  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_in
    if((~rst_ni) | clear)
      cnt_in = 32'b0;
    else if((a_i.valid)&(a_i.ready))
      cnt_in = cnt_in + 1;
    else
      cnt_in = cnt_in;
  end

  always_ff @(posedge clk_i or negedge rst_ni or posedge done)
  begin: engine_cnt_out
    if((~rst_ni) | clear)
      cnt_out = 32'b0;
    else if((done)&(cnt_in>cnt_out))
      cnt_out = cnt_out + 1;
    else
      cnt_out = cnt_out;
  end

  % endif

</%def>\

<%
#########################
## Streaming interface ##
#########################
%>

<%def name="intf_streaming(is_intf, target, n_sink, n_source)">\

  % if is_intf is True:

  /* ${target} streaming interface control. */

  // At the moment output strobe is always '1
  // All bytes of output streams are written
  // to TCDM
  always_comb
  begin
    % for j in range (n_source):
    o_${stream_out[j]}.strb = '1;
    % endfor
  end

  % endif

</%def>\

