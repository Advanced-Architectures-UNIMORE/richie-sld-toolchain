<%
##############################################
## Kernel interface -> AP_CTRL (Vivado HLS) ##
##############################################
%>

<%def name="intf_ap_ctrl(is_intf)">\

  % if is_intf:

  // Application-specific hardware kernel ~~~~~~~~~~
  ${target} i_${target} (
    // Global signals
    .ap_clk             ( clk_i            ), 
    .ap_rst_n           ( rst_ni           ), 

    // Input data (to-hwpe)
    % for i in range (n_sink):
    ${axi_stream_inst_in(stream_in[i], i, (n_sink + n_source))}
    % endfor 

    // Output data (from-hwpe)
    % for j in range (n_source):
    ${axi_stream_inst_out(stream_out[j], j+i+1, (n_sink + n_source))}
    % endfor 

    // Algorithm parameters
    % for i in range (custom_reg_num):
    ${static_reg_to_engine_intf(custom_reg_name[i], custom_reg_isport[i])}
    % endfor 

    // Control signals
    .ap_start           ( ctrl_i.start     ),
    .ap_done            ( done             ), 
    .ap_idle            ( idle             ), 
    .ap_ready           ( ready            )
  );

  % endif

</%def>\

<%
################################
## Engine controls (from FSM) ##
################################
%>

<%def name="ctrl_to_engine(is_intf)">\

  // ${target} control
  logic clear;

  assign clear = ctrl_i.clear;

</%def>\

<%
###########################
## Engine flags (to FSM) ##
###########################
%>

<%def name="flags_from_engine(is_intf)">\

  logic done, idle, ready;

  assign flags_o.done = done;
  assign flags_o.idle = idle;
  assign flags_o.cnt = cnt_out;

  always_ff @(posedge clk_i or negedge rst_ni)
  begin: fsm_ready
    if(~rst_ni)
      flags_o.ready = 1'b0;
    else if(~(ready | idle))
      flags_o.ready = 1'b0;
    else
      flags_o.ready = 1'b1;
  end

  // IN/OUT synchronization
  logic unsigned [$clog2(${target}_CNT_LEN):0] cnt_in; 
  logic unsigned [$clog2(${target}_CNT_LEN):0] cnt_out;

  always_ff @(posedge clk_i or negedge rst_ni)
  begin: engine_cnt_in
    if((~rst_ni) | clear)
      cnt_in = 32'b0;
    else if((a_i.valid)&(a_i.ready))
      cnt_in = cnt_in + 1;
    else
      cnt_in = cnt_in;
  end

  always_ff @(posedge clk_i or negedge rst_ni or posedge done)
  begin: engine_cnt_out
    if((~rst_ni) | clear)
      cnt_out = 32'b0;
    else if((done)&(cnt_in>cnt_out))
      cnt_out = cnt_out + 1;
    else
      cnt_out = cnt_out;
  end

</%def>\

<%
#########################
## Streaming interface ##
#########################
%>

<%def name="intf_streaming(is_intf)">\

  // At the moment output strobe is always '1
  // All bytes of output streams are written
  // to TCDM
  always_comb
  begin
    % for i in range (n_sink, n_sink + n_source):
    ${chr(i+97)}_o.strb = '1;
    % endfor
  end

</%def>\

