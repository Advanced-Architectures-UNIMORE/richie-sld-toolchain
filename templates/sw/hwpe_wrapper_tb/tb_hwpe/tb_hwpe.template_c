
/*
 * Copyright (C) 2019 ETH Zurich and University of Bologna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 *
 * Authors:     Gianluca Bellocchi <gianluca.bellocchi@unimore.it>
 *
 */

/* Libraries inclusion */
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

#include <hero-target.h>

/* HWPE. */
#include "inc/hwpe_lib/archi_hwpe.h"
#include "inc/hwpe_lib/hal_hwpe.h"

// /* Event unit. */
// #include "inc/eu/archi_eu_v3.h"
// #include "inc/eu/hal_eu_eu_v3.h"

/* Stimuli */
// Include initialization stimuli
// Include golden results

/* 
  Being RTL simualtion very slow, a single data stripe is processed in order
  to assess the functionality of the cluster-couple Hardware Accelerator.
*/

/* HWPE test */
int ${target}_tb(
  % for i in range (n_sink):
  ${stream_in[i]}_width,
  ${stream_in[i]}_height,      
  ${stream_in[i]}_stripe_height, 
  % endfor

  % for j in range (n_source-1):
  ${stream_out[j]}_width,      
  ${stream_out[j]}_height,    
  ${stream_out[j]}_stripe_height, 
  % endfor

  ${stream_out[n_source-1]}_width,        
  ${stream_out[n_source-1]}_height,       
  ${stream_out[n_source-1]}_stripe_height
) {

  printf("Testbench application - DUT: ${target}\n");

  printf("Initializating test parameters\n");

  /* Init */
  omp_set_num_threads(1);
  volatile int errors = 0;
  int i,j,k,cnt;
  int offload_id_tmp, offload_id;

  /* Dataset parameters. */
  % for i in range (n_sink):
  // input ${stream_in[i]}
  const unsigned ${stream_in[i]}_stim_dim             = ${stream_in[i]}_width * ${stream_in[i]}_height;
  const unsigned ${stream_in[i]}_stripe_in_len        = ${stream_in[i]}_width * ${stream_in[i]}_stripe_height;
  % endfor

  % for j in range (n_source):
  // output ${stream_out[j]}
  const unsigned ${stream_out[j]}_stim_dim             = ${stream_out[j]}_width * ${stream_out[j]}_height;
  const unsigned ${stream_out[j]}_stripe_out_len        = ${stream_out[j]}_width * ${stream_out[j]}_stripe_height;
  % endfor

  /* Address generator - Parameters */
  % for i in range (n_sink):
  // input ${stream_in[i]}
    % if (is_parallel_in[i]):
  const unsigned ${stream_in[i]}_parallelism_factor     = 16;
  const unsigned ${stream_in[i]}_trans_size             = (${stream_in[i]}_width * ${stream_in[i]}_stripe_height * ${stream_in[i]}_stripe_height) / ${stream_in[i]}_parallelism_factor;
  const unsigned ${stream_in[i]}_line_stride            = 0;
  const unsigned ${stream_in[i]}_line_length            = ${stream_in[i]}_width / ${stream_in[i]}_parallelism_factor;
  const unsigned ${stream_in[i]}_feat_stride            = ${stream_in[i]}_width * sizeof(uint32_t);
  const unsigned ${stream_in[i]}_feat_length            = ${stream_in[i]}_stripe_height;
  const unsigned ${stream_in[i]}_feat_roll              = ${stream_in[i]}_stripe_height; 
  const unsigned ${stream_in[i]}_loop_outer             = 0;
  const unsigned ${stream_in[i]}_realign_type           = 0; 
  const unsigned ${stream_in[i]}_step                   = ${stream_in[i]}_parallelism_factor * sizeof(uint32_t);
  const unsigned ${stream_in[i]}_port_offset            = sizeof(uint32_t);
    % else:
  const unsigned ${stream_in[i]}_trans_size             = ${stream_in[i]}_width * ${stream_in[i]}_stripe_height * ${stream_in[i]}_stripe_height;
  const unsigned ${stream_in[i]}_line_stride            = 0;
  const unsigned ${stream_in[i]}_line_length            = ${stream_in[i]}_width;
  const unsigned ${stream_in[i]}_feat_stride            = ${stream_in[i]}_width * sizeof(uint32_t);
  const unsigned ${stream_in[i]}_feat_length            = ${stream_in[i]}_stripe_height;
  const unsigned ${stream_in[i]}_feat_roll              = ${stream_in[i]}_stripe_height; 
  const unsigned ${stream_in[i]}_loop_outer             = 0;
  const unsigned ${stream_in[i]}_realign_type           = 0;
    % endif
  % endfor

  % for j in range (n_source):
  // output ${stream_out[j]}
    % if (is_parallel_out[j]):
  const unsigned ${stream_out[j]}_parallelism_factor    = 16; 
  const unsigned ${stream_out[j]}_trans_size            = (${stream_out[j]}_width * ${stream_out[j]}_stripe_height * ${stream_out[j]}_stripe_height) / ${stream_out[j]}_parallelism_factor;
  const unsigned ${stream_out[j]}_line_stride           = 0;
  const unsigned ${stream_out[j]}_line_length           = ${stream_out[j]}_width / ${stream_out[j]}_parallelism_factor;
  const unsigned ${stream_out[j]}_feat_stride           = ${stream_out[j]}_width * sizeof(uint32_t);
  const unsigned ${stream_out[j]}_feat_length           = ${stream_out[j]}_stripe_height;
  const unsigned ${stream_out[j]}_feat_roll             = ${stream_out[j]}_stripe_height; 
  const unsigned ${stream_out[j]}_loop_outer            = 0;
  const unsigned ${stream_out[j]}_realign_type          = 0;
  const unsigned ${stream_out[j]}_step                  = ${stream_out[j]}_parallelism_factor * sizeof(uint32_t);
  const unsigned ${stream_out[j]}_port_offset           = sizeof(uint32_t);
    % else:
  const unsigned ${stream_out[j]}_trans_size            = ${stream_out[j]}_stripe_height * ${stream_out[j]}_stripe_height; // stripe_height * stripe_height;
  const unsigned ${stream_out[j]}_line_stride           = sizeof(uint32_t);
  const unsigned ${stream_out[j]}_line_length           = 1;
  const unsigned ${stream_out[j]}_feat_stride           = ${stream_out[j]}_stripe_height * sizeof(uint32_t);
  const unsigned ${stream_out[j]}_feat_length           = ${stream_out[j]}_stripe_height;
  const unsigned ${stream_out[j]}_feat_roll             = ${stream_out[j]}_stripe_height;
  const unsigned ${stream_out[j]}_loop_outer            = 0;
  const unsigned ${stream_out[j]}_realign_type          = 0; // Unused.
    % endif
  % endfor
  
  printf("Allocation and initialization of L1 stimuli\n");

  /* L1 init - Input stimuli */

  % for i in range (n_sink):
  // input ${stream_in[i]}
  int32_t * ${stream_in[i]}_l1 = hero_l1malloc(sizeof(int32_t)*${stream_in[i]}_stripe_in_len);
  % endfor

  % for j in range (n_source):
  // output ${stream_out[j]}
  int32_t * ${stream_out[j]}_l1 = hero_l1malloc(sizeof(int32_t)*${stream_out[j]}_stripe_out_len);
  int32_t * ${stream_out[j]}_golden_l1 = hero_l1malloc(sizeof(int32_t)*${stream_out[j]}_stripe_out_len);
  % endfor

  /* Initialize stimuli. */

  % for i in range (n_sink):
  // input ${stream_in[i]}
  for (i = 0; i < ${stream_in[i]}_stripe_height; i++){
    for (j = 0; j < ${stream_in[i]}_width; j++){
      ${stream_in[i]}_l1[i*${stream_in[i]}_width+j] = // Insert an initialization value
    }
  }
  % endfor

  % for j in range (n_source):
  // output ${stream_out[j]}
  for (i = 0; i < ${stream_out[j]}_stripe_height; i++){
    for (j = 0; j < ${stream_out[j]}_width; j++){
      ${stream_out[j]}_l1[i*${stream_out[j]}_width+j] = // Insert an initialization value
    }
  }

  // output golden results ${stream_out[j]}
  for (i = 0; i < ${stream_out[j]}_stripe_height; i++){
    for (j = 0; j < ${stream_out[j]}_width; j++){
      ${stream_out[j]}_golden_l1[i*${stream_out[j]}_width+j] = // Insert an initialization value
    }
  }
  % endfor

  printf("DUT programming\n");

  hwpe_cg_enable();

  while((offload_id_tmp = hwpe_acquire_job()) < 0)

  /* Micro-code processor */
  // Set up bytecode
  // hwpe_bytecode_set(HWPE_LOOPS1_OFFS,           0x00000000);
  // hwpe_bytecode_set(HWPE_BYTECODE5_LOOPS0_OFFS, 0x00000000);
  // hwpe_bytecode_set(HWPE_BYTECODE4_OFFS,        0x00000000);
  // hwpe_bytecode_set(HWPE_BYTECODE3_OFFS,        0x00000000);
  // hwpe_bytecode_set(HWPE_BYTECODE2_OFFS,        0x00000000);
  // hwpe_bytecode_set(HWPE_BYTECODE1_OFFS,        0x00000808);
  // hwpe_bytecode_set(HWPE_BYTECODE0_OFFS,        0x09e22c24);

  // Ucode parameters
  // hwpe_nb_iter_set(stripe_height);
  // hwpe_linestride_set(width*sizeof(uint32_t));
  // hwpe_tilestride_set(stripe_height*sizeof(uint32_t));





  // FSM
  
  % for j in range (n_source):
  // output ${stream_out[j]}
  hwpe_len_iter_set(${stream_out[j]}_stripe_height * ${stream_out[j]}_stripe_height - 1);
  % endfor





  // Address generator

  % for i in range (n_sink):
  // input ${stream_in[i]}
    % if (is_parallel_in[i]):
  hwpe_addr_gen_${stream_in[i]}(
    ${stream_in[i]}_trans_size,
    ${stream_in[i]}_line_stride,
    ${stream_in[i]}_line_length,
    ${stream_in[i]}_feat_stride,
    ${stream_in[i]}_feat_length,
    ${stream_in[i]}_feat_roll,
    ${stream_in[i]}_loop_outer,
    ${stream_in[i]}_realign_type,
    ${stream_in[i]}_parallelism_factor,
    ${stream_in[i]}_port_offset,
    ${stream_in[i]}_step
  );
    % else:
  hwpe_addr_gen_${stream_in[i]}(
    ${stream_in[i]}_trans_size,
    ${stream_in[i]}_line_stride,
    ${stream_in[i]}_line_length,
    ${stream_in[i]}_feat_stride,
    ${stream_in[i]}_feat_length,
    ${stream_in[i]}_feat_roll,
    ${stream_in[i]}_loop_outer,
    ${stream_in[i]}_realign_type
  );
    % endif
  % endfor

  % for j in range (n_source):
  // output ${stream_out[j]}
    % if (is_parallel_in[i]):
  hwpe_addr_gen_${stream_out[j]}(
    ${stream_out[j]}_trans_size,
    ${stream_out[j]}_line_stride,
    ${stream_out[j]}_line_length,
    ${stream_out[j]}_feat_stride,
    ${stream_out[j]}_feat_length,
    ${stream_out[j]}_feat_roll,
    ${stream_out[j]}_loop_outer,
    ${stream_out[j]}_realign_type,
    ${stream_out[j]}_parallelism_factor,
    ${stream_out[j]}_port_offset,
    ${stream_out[j]}_step
  );
    % else:
  hwpe_addr_gen_${stream_out[j]}(
    ${stream_out[j]}_trans_size,
    ${stream_out[j]}_line_stride,
    ${stream_out[j]}_line_length,
    ${stream_out[j]}_feat_stride,
    ${stream_out[j]}_feat_length,
    ${stream_out[j]}_feat_roll,
    ${stream_out[j]}_loop_outer,
    ${stream_out[j]}_realign_type
  );
    % endif
  % endfor


  /* Set TCDM address reg values */

  % for i in range (n_sink):
  // input ${stream_in[i]}
  hwpe_${stream_in[i]}_addr_set( ${stream_in[i]}_l1 );
  % endfor

  % for j in range (n_source):
  // output ${stream_out[j]}
  hwpe_${stream_out[j]}_addr_set( ${stream_out[j]}_l1 );
  % endfor







  /* DUT execution */

  printf("DUT execution start!\n");

  // Trigger execution
  hwpe_trigger_job();

  // event unit
  eu_evt_maskWaitAndClr(1 << 12);

  printf("DUT end of execution!\n");

  hwpe_soft_clear();
  hwpe_cg_disable();

  // // /* Error check on L2. */
  // printf("Results check");

  // for (i = 0; i < stripe_height; i++){
  //   for (j = 0; j < stripe_height; j++){
  //     if(y_l1[i*stripe_height+j] != y_golden[i*stripe_height+j]){ 
  //       printf("[%d]    L1 - y_test:    %d \n",  i*stripe_height+j, y_l1[i*stripe_height+j]);
  //       printf("[%d]    L1 - y_golden:  %d\n\n", i*stripe_height+j, y_golden[i*stripe_height+j]);
  //       errors++;
  //     }
  //   }
  // }

  // /* Return errors */
  // printf("errors: %d\n", errors);
  // printf("end\n");

  return errors;
}

int main() {

  /* Parameters. */

  % for i in range (n_sink):
  uint32_t ${stream_in[i]}_width          = // Insert a value
  uint32_t ${stream_in[i]}_height         = // Insert a value
  uint32_t ${stream_in[i]}_stripe_height  = // Insert a value
  % endfor

  % for j in range (n_source):
  uint32_t ${stream_out[j]}_width          = // Insert a value
  uint32_t ${stream_out[j]}_height         = // Insert a value
  uint32_t ${stream_out[j]}_stripe_height  = // Insert a value
  % endfor

  /* Launch application. */
  while(
    !${target}_tb(
      % for i in range (n_sink):
      ${stream_in[i]}_width,
      ${stream_in[i]}_height,      
      ${stream_in[i]}_stripe_height, 
      % endfor

      % for j in range (n_source-1):
      ${stream_out[j]}_width,      
      ${stream_out[j]}_height,    
      ${stream_out[j]}_stripe_height, 
      % endfor

      ${stream_out[n_source-1]}_width,        
      ${stream_out[n_source-1]}_height,       
      ${stream_out[n_source-1]}_stripe_height
    )
  )

  return 0;
}