/*
 * Copyright (C) 2019 ETH Zurich and University of Bologna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * 
 * Authors:     Gianluca Bellocchi <gianluca.bellocchi@unimore.it>
 % if (author!='Gianluca Bellocchi'):
 * Contribute:  ${author} ${email}
 % endif
 *
 */

/* Libraries inclusion */

#include <omp.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

#include "inc/hwpe_lib/archi_hwpe.h"
#include "inc/hwpe_lib/hal_hwpe.h"

#include "inc/hero_lib/hero_memory_map.h"
#include "inc/hero_lib/pulp_fc.h"

#include "inc/test_lib/test_hwpe.h"

/* Stimuli */
#include "inc/stim/stim_def.h"
#include "inc/stim/stim_input.h"
#include "inc/stim/reg_values.h"
#include "inc/stim/results.h"

/* Defines */
#include "inc/test_lib/defines.h"

/* HWPE test */

int ${TARGET}(uint32_t stim_dim, uint32_t stripe_len) {

  /* Init */

  omp_set_num_threads(1);

  volatile int errors = 0;
  int i,j,k,cnt;
  
  int offload_id_tmp, offload_id;

  const unsigned stim_dim_local   = hero_tryread((unsigned int *)&stim_dim);
  const unsigned stripe_len_local = hero_tryread((unsigned int *)&stripe_len);

  const unsigned num_unfiltered = stim_dim_local;
  const unsigned num_stripe     = num_unfiltered / stripe_len_local;

  /* L2 init - Input stimuli */

  % for i in range (n_sink):
  ${stream_in_dtype[i]} * ${stream_in[i]}_l2 = (${stream_in_dtype[i]} *)malloc(sizeof(${stream_in_dtype[i]})*num_unfiltered);
  % endfor

  % for i in range (n_sink):
  memset((void *)${stream_in[i]}_l2, 0, (size_t)(num_unfiltered));
  % endfor

  /* L2 init - Output result */

  % for j in range (n_source):
  ${stream_out_dtype[j]} * ${stream_out[j]}_l2  = (${stream_out_dtype[j]} *)malloc(sizeof(${stream_out_dtype[j]})*num_unfiltered);
  % endfor

  % for j in range (n_source):
  memset((void *)${stream_out[j]}_l2,  0, (size_t)(num_unfiltered));
  % endfor

  #if DB
  
  #else

    /* L1 init - Input stimuli */

    % for i in range (n_sink):
    ${stream_in_dtype[i]} * ${stream_in[i]}_l1 = hero_l1malloc(sizeof(${stream_in_dtype[i]})*stripe_len_local);
    % endfor

    % for i in range (n_sink):
    memset((void *)${stream_in[i]}_l1, 0, (size_t)(stripe_len_local));
    % endfor

    /* L1 init - Output result */

    % for j in range (n_source):
    ${stream_out_dtype[j]} * ${stream_out[j]}_l1  = hero_l1malloc(sizeof(${stream_out_dtype[j]})*stripe_len_local);
    % endfor

    % for j in range (n_source):
    memset((void *)${stream_out[j]}_l1,  0, (size_t)(num_unfiltered));
    % endfor

  #endif

  #if DB

  #else

    hwpe_cg_enable();

    /* Processing loops */

    for (i = 0; i < (num_stripe); i++){

      while((offload_id_tmp = hwpe_acquire_job()) < 0)

      /* Micro-code processor */

      // Set up bytecode
      hwpe_bytecode_set(HWPE_LOOPS1_OFFS,           0x00000000);
      hwpe_bytecode_set(HWPE_BYTECODE5_LOOPS0_OFFS, 0x00040000);
      hwpe_bytecode_set(HWPE_BYTECODE4_OFFS,        0x00000000);
      hwpe_bytecode_set(HWPE_BYTECODE3_OFFS,        0x00000000);
      hwpe_bytecode_set(HWPE_BYTECODE2_OFFS,        0x00000000);
      hwpe_bytecode_set(HWPE_BYTECODE1_OFFS,        0x000008cd);
      hwpe_bytecode_set(HWPE_BYTECODE0_OFFS,        0x11a12c05);

      // Ucode parameters
      hwpe_nb_iter_set(1);  
      hwpe_vectstride_set(sizeof(${stream_in[0]}_l1)*4);
      
      /* Job-dependent programming */

      % for i in range (n_sink):
      ${stream_in_dtype[i]} * curr_${stream_in[i]}_l2 = (${stream_in_dtype[i]} *) (${stream_in[i]}_l2 + i*stripe_len_local);
      % endfor
      % for j in range (n_source):
      ${stream_out_dtype[j]} * curr_${stream_out[j]}_l2 = (${stream_out_dtype[j]} *) (${stream_out[j]}_l2 + i*stripe_len_local);
      % endfor

      // Stripe -> TCDM

      % for i in range (n_sink):
      hero_dma_memcpy((void *)${stream_in[i]}_l1, curr_${stream_in[i]}_l2, sizeof(${stream_in_dtype[i]})*stripe_len_local);
      % endfor

      // Set TCDM address reg values

      % for i in range (n_sink):
      hwpe_${chr(i+97)}_addr_set( ${stream_in[i]}_l1 );
      % endfor

      % for j in range (n_source):
      hwpe_${chr(i+j+98)}_addr_set( ${stream_out[j]}_l1 );
      % endfor

      hwpe_len_iter_set(stripe_len_local-1);

      // Set custom reg values
      % for i in range (custom_reg_num):
      <% NAME=custom_reg_name[i].upper() %>
      <% name=custom_reg_name[i].lower() %>
      hwpe_${name}_set( /* Value of ${NAME} */ );
      % endfor

      hwpe_trigger_job();

      printf("Start of processing - STATUS: %x , STRIPE #%d\n", hwpe_get_status(), i);

      // Handle interrupt
      int u=1;
      while(u){
        if (HWPE_READ(HWPE_FINISHED))
          u=0;
      }

      printf("End of processing - STATUS: %x , STRIPE #%d\n", hwpe_get_status(), i);

      // Stripe -> L2

      % for i in range (n_source):
      hero_dma_memcpy(curr_${stream_out[i]}_l2 , (void *)${stream_out[i]}_l1, sizeof(${stream_out_dtype[i]})*stripe_len_local);
      % endfor

      hwpe_soft_clear();
    }

    hwpe_cg_disable();

    /* Free L1 memory */

    % for i in range (n_sink):
    hero_l1free(${stream_in[i]}_l1);
    % endfor

    % for i in range (n_source):
    hero_l1free(${stream_out[i]}_l1);
    % endfor

  #endif

  /* Error check */

  //

  /* Free L2 memory */

  % for i in range (n_sink):
  free(${stream_in[i]}_l2);
  % endfor

  % for i in range (n_source):
  free(${stream_out[i]}_l2);
  % endfor

  /* Return errors */

  *(int *) 0x80000000 = errors;

  printf("errors: %d\n", errors);
  printf("end\n");
  
  return errors;
}

int main() {
  /* Dimension of stimuli array */
  uint32_t stim_dim   = STIM_DIM;
  /* Length of single stimuli stripe */
  uint32_t stripe_len = STRIPE_LEN;

  while(!${TARGET}(stim_dim, stripe_len))
  return 0;
}